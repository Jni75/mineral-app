/* eslint-disable fp/no-loops, fp/no-mutation, fp/no-mutating-methods, fp/no-let, no-constant-condition */

import path from "path";
import fs from "fs/promises";
import { program } from "commander";
import numbro from "numbro";
import chalk from "chalk";

import { epochReset } from "../codegen/mineral/mine/functions";
import { Config, MINE } from "../codegen/mineral/mine/structs";
import { Miner } from "../codegen/mineral/miner/structs";

import { bcs } from "@mysten/sui/bcs";
import { decodeSuiPrivateKey } from "@mysten/sui/cryptography";
import {
  SuiTransactionBlockResponse,
  SuiClient,
  getFullnodeUrl,
} from "@mysten/sui/client";
import { Ed25519Keypair } from "@mysten/sui/keypairs/ed25519";
import {
  SUI_TYPE_ARG,
  SUI_DECIMALS,
  SUI_CLOCK_OBJECT_ID,
} from "@mysten/sui/utils";
import { Transaction } from "@mysten/sui/transactions";

import {
  MineProgress,
  launch,
  validateHash,
  createHash,
  getProof,
  getOrCreateMiner,
  fetchBus,
  snooze,
  submitProof,
  fetchBuses,
} from "../common";
import * as constants from "../constants";

const { WALLET, RPC } = process.env;

const WARN_ICON = String.fromCodePoint(0x26a0, 0xfe0f);
const PATH = path.join(path.dirname(process.execPath), "./mineral.txt");
const CONFIG_HEADER =
  "/* This file was generated by the Mineral CLI - https://mineral.supply/ */";
const USAGE_GUIDE =
  "https://github.com/ronanyeah/mineral-app/blob/master/cli/README.md";
const SETUP_PROMPT = "Consult the setup guide: " + USAGE_GUIDE;

const settings = (() => {
  const rpcUrl = RPC || getFullnodeUrl("mainnet");
  return {
    rpc: new SuiClient({
      url: rpcUrl,
    }),
    rpcUrl,
  };
})();

program
  .name("mineral")
  .description(
    `Mineral CLI Miner\nhttps://mineral.supply/\n\nUser guide:\n${USAGE_GUIDE}`
  )
  .version("1.1.0");

program
  .command("profile")
  .description("View your mining stats")
  .action((_options) =>
    (async () => {
      const wallet = readWallet();
      const pub = wallet.toSuiAddress();
      console.log(greenText("Wallet:"), pub);
      const miner = await getProof(settings.rpc, pub);
      if (miner) {
        console.log(greenText("Miner:"), miner.id);
      }
      console.log(blueText("RPC:"), settings.rpcUrl);
      const results = await Promise.all([
        (async () => {
          const bal = await settings.rpc.getBalance({
            owner: pub,
            coinType: SUI_TYPE_ARG,
          });
          const val = formatBig(BigInt(bal.totalBalance), SUI_DECIMALS);
          return [`💧 Sui Balance: ${val} SUI`];
        })(),
        (async () => {
          const bal = await settings.rpc.getBalance({
            owner: pub,
            coinType: MINE.$typeName,
          });
          const val = formatBig(BigInt(bal.totalBalance), SUI_DECIMALS);
          return [`⛏️  Mineral Balance: ${val} $MINE`];
        })(),
        (async () => {
          const [v1, v2] = miner
            ? [formatBig(miner.totalRewards, 9), miner.totalHashes]
            : [0.0, 0];
          return [
            `💰 Lifetime rewards: ${v1} $MINE`,
            `🏭 Lifetime hashes: ${v2}`,
          ];
        })(),
      ]);
      results.flat().forEach((val) => console.log(val));
    })().catch(console.error)
  );

program
  .command("stats")
  .description("View global Mineral stats")
  .action((_options) =>
    (async () => {
      const [config, bus] = await Promise.all([
        Config.fetch(settings.rpc, constants.CONFIG),
        fetchBus(settings.rpc),
      ]);
      console.log(
        "Total distributed rewards:",
        Number(config.totalRewards) / 1_000_000_000,
        "$MINE"
      );
      console.log("Total hashes processed:", Number(config.totalHashes));
      console.log(
        "Current reward rate:",
        Number(bus.rewardRate) / 1_000_000_000,
        "$MINE / hash"
      );
      console.log("Current difficulty:", bus.difficulty);
    })().catch(console.error)
  );

program
  .command("create-wallet")
  .description("Create a new Sui wallet")
  .action(async (_options) => {
    const wallet = new Ed25519Keypair();
    console.log(greenText("Wallet created:"), wallet.toSuiAddress());
    console.log(redText("Private key:"), wallet.getSecretKey());
    console.log(blueText("Mineral CLI usage guide:"), USAGE_GUIDE);
  });

program
  .command("mine")
  .description("Start mining ⛏️")
  .option("--track-progress", "Save hash checking progress while mining")
  .action((options) =>
    (async () => {
      const wallet = readWallet();
      const walletAddr = wallet.toSuiAddress();

      const persist = Boolean(options.trackProgress);

      const [mineralObjs, bal] = await Promise.all([
        settings.rpc.getCoins({
          coinType: MINE.$typeName,
          owner: walletAddr,
          limit: 1,
        }),
        settings.rpc.getBalance({
          owner: walletAddr,
          coinType: SUI_TYPE_ARG,
        }),
      ]);

      if (Number(bal.totalBalance) < 0.1) {
        console.log(redText("Low balance"), "in wallet:", walletAddr);
        return program.error("Send some SUI to this wallet to enable mining.");
      }

      console.error(greenText("Mining with wallet:"), walletAddr);
      console.error(
        blueText("Progress tracking:"),
        persist ? greenText("ON") : redText("OFF")
      );

      const minerAccount = await getOrCreateMiner(wallet, settings.rpc);
      const bus = await fetchBus(settings.rpc);

      if (!minerAccount) {
        return program.error("Miner account not created!");
      }

      const currentHash = new Uint8Array(minerAccount.currentHash);
      const startNonce =
        (persist && (await readProgress(currentHash))) || BigInt(0);

      const mineralObj = mineralObjs.data[0];
      runner(
        settings.rpc,
        bus.difficulty,
        wallet,
        minerAccount.id,
        { hash: currentHash, nonce: startNonce },
        mineralObj ? mineralObj.coinObjectId : null,
        persist
      );

      console.log("⛏️  Mining started");
      console.log("🔍 Looking for a valid proof...");
    })().catch(console.error)
  );

function readWallet(): Ed25519Keypair {
  if (!WALLET) {
    throw program.error(WARN_ICON + "  Wallet not found.\n" + SETUP_PROMPT);
  }
  if (!WALLET.startsWith("suiprivkey")) {
    throw program.error(
      WARN_ICON + "  Invalid wallet private key provided.\n" + SETUP_PROMPT
    );
  }
  return Ed25519Keypair.fromSecretKey(decodeSuiPrivateKey(WALLET).secretKey);
}

async function readProgress(currentHash: Uint8Array): Promise<bigint | null> {
  return fs
    .readFile(PATH, "utf8")
    .then((data) => {
      const obj = JSON.parse(data.slice(CONFIG_HEADER.length));
      const savedProgress: MineProgress = obj.progress;
      return bufferEq(new Uint8Array(savedProgress.hash), currentHash)
        ? BigInt(savedProgress.nonce)
        : null;
    })
    .catch((_err) => {
      return null;
    });
}

async function writeProgress(data: MineProgress) {
  return fs.writeFile(
    PATH,
    CONFIG_HEADER +
      "\n" +
      JSON.stringify({
        progress: {
          hash: Array.from(data.hash),
          nonce: data.nonce.toString(),
        },
      })
  );
}

program.parse(process.argv);

async function runner(
  client: SuiClient,
  difficulty: number,
  wallet: Ed25519Keypair,
  minerId: string,
  startState: MineProgress,
  startCoinId: string | null,
  saveProgress: boolean
) {
  const signerBytes = bcs.Address.serialize(wallet.toSuiAddress()).toBytes();

  let coinId = startCoinId;
  let completed = false;
  let currentHash = startState.hash;
  let nonce = startState.nonce;

  while (true) {
    await (async () => {
      if (completed) {
        const miner = await Miner.fetch(client, minerId);
        const fetchedHash = new Uint8Array(miner.currentHash);

        // Check from RPC if hash has changed
        if (bufferEq(currentHash, fetchedHash)) {
          return snooze(2000);
        } else {
          currentHash = fetchedHash;
          nonce = BigInt(0);
          completed = false;
        }
      }

      const hash = createHash(currentHash, signerBytes, nonce);
      const hashIsValid = validateHash(hash, difficulty);
      if (hashIsValid) {
        const buses = await fetchBuses(client);
        const mostFundedBus = buses[0]!;

        const busOk = (() => {
          const fundsOk =
            mostFundedBus.rewards.value >= mostFundedBus.rewardRate;

          const threshold =
            Number(mostFundedBus.lastReset) + constants.EPOCH_LENGTH;

          const buffer = 4_000;
          const resetTimeOk = Date.now() < threshold - buffer;

          return resetTimeOk && fundsOk;
        })();

        if (!busOk) {
          const resetOk = await waitUntilNextReset(
            client,
            mostFundedBus.lastReset
          );
          if (!resetOk) {
            await execReset(client, wallet);
          }
          return;
        }

        const proofData = {
          proof: {
            currentHash: Array.from(currentHash),
            nonce: Number(nonce),
          },
          miner: minerId,
          coinObject: coinId,
        };

        console.log("✅ Valid hash found");
        console.log("📡 Submitting transaction");
        await submitProof(wallet, client, proofData, mostFundedBus);

        console.log("🏅 Mining success!");
        console.log("🔍 Looking for next hash...");

        completed = true;

        if (!coinId) {
          client
            .getCoins({
              coinType: MINE.$typeName,
              owner: wallet.toSuiAddress(),
              limit: 1,
            })
            .then((objs) => {
              const coinObj = objs.data[0];
              if (coinObj) {
                coinId = coinObj.coinObjectId;
              }
            });
        }
      } else {
        if (saveProgress && nonce % BigInt(1_000_000) == BigInt(0)) {
          //console.log("checkpoint");
          await writeProgress({ hash: currentHash, nonce });
        }
        nonce++;
      }
    })().catch((e) => {
      console.error(e);
      return snooze(500);
    });
  }
}

function formatBig(n: bigint, decimals: number) {
  return numbro(Number(n) / Math.pow(10, decimals)).format({
    mantissa: 9,
    trimMantissa: true,
  });
}

function bufferEq(a: Uint8Array, b: Uint8Array): boolean {
  function bufferToHex(buffer: Uint8Array): string {
    return Array.from(buffer)
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }
  return bufferToHex(a) === bufferToHex(b);
}

async function execReset(
  client: SuiClient,
  wallet: Ed25519Keypair
): Promise<SuiTransactionBlockResponse> {
  const txb = new Transaction();
  epochReset(txb, {
    config: constants.CONFIG,
    buses: constants.BUSES.map((x) =>
      txb.sharedObjectRef({
        objectId: x,
        mutable: true,
        initialSharedVersion: 0,
      })
    ),
    clock: SUI_CLOCK_OBJECT_ID,
  });

  return launch(txb, client, wallet, 1_000_000);
}

async function waitUntilNextReset(
  client: SuiClient,
  currentReset: bigint
): Promise<boolean> {
  const bus = await fetchBus(client);
  const nextReset = Number(bus.lastReset) + constants.EPOCH_LENGTH;
  const timeUntilNextReset = nextReset - Date.now();
  if (timeUntilNextReset > 0) {
    await snooze(timeUntilNextReset);
  }
  while (true) {
    const freshBus = await fetchBus(client);
    if (freshBus.lastReset !== currentReset) {
      return true;
    } else {
      // Reset has not occurred
      if (Date.now() > nextReset + 12_000) {
        return false;
      }
      await snooze(1500);
    }
  }
}

function blueText(val: string) {
  //import { styleText } from "node:util";
  //styleText("blue", "foo"),
  return chalk.blue(val);
}

function greenText(val: string) {
  return chalk.green(val);
}

function redText(val: string) {
  return chalk.red(val);
}
